# Vertical Slice Architecture (VSA)

VSA is based on IODA Sleepy Hollow. VSA is also based on the Event Sourcing pattern.

In VSA, the Processor does not integrate calls to functions from functional modules in its entry points. Instead, each entry point represents the implementation of a slice based on user requirements, which are implemented in a dedicated class.

Instead of implementing the requirements for which various entry points stand in overarching modules that the Processor must orchestrate, they are strictly separated into specific modules called "Slices." Consequently, slices are independent of one another.

Functional modules share common state in a central domain data model. Slices do not. Slices share state in an Event Store. In the Event Store, state changes are stored in the form of events as very fine-grained differences.

Slices do not communicate with each other; they merely deposit their results in the Event Store, from which other slices can retrieve them as needed. Events, which are generated by slices as results of executing Commands, are recorded by an Event Store in chronological order. Other slices query the Event Store for relevant events (Context) and have it play them back.

## Anatomy of a Slice

Each slice is implemented as a class that knows the Event Store.

### process()

Each slice has a `process()` method that accepts a Request (Command or Query (CQS)) and returns a Response.

- **Commands** lead to events being generated and recorded in the Event Store. Their response is merely a status message regarding the success or failure of the command's execution. However, the status message may contain metadata, such as IDs of generated events, the amount of processed data, or an error message.
- **Queries** merely have the Event Store play back events and project them into a result data model as a response.

### Processing Flow

Within `process()`, the processing of the Request follows a fundamental sequence:

1. **Obtainment of the Context** for processing, i.e., the events relevant to producing a response.
2. **Construction of a Context Model** from the events in the context. The model is a condensed form of the event data, reduced to the absolute essentials for the following steps. Slices do not rely on a central, uniform data model but instead build an optimized one for their specific purposes. A Context Model can be trivial, consisting only of a single number, or a complex web of objects. The simpler, the better for further processing. (In some cases, slices may also share a Context or Context Model.)
3. **Validation** of the Request based on the Context Model (if applicable).
4. **Processing** of the Request. For Commands, this involves generating new events to change the state in the Event Store. For Queries, it involves projecting the Context Model + Request into a resulting data model.
5. For Commands, the new events are finally **recorded in the Event Store**. This can be done conditionally (**conditional append**) to ensure the consistency of the overall state in the Event Store. A conditional recording occurs taking into account the Event Store Query used to obtain the context. A recording then only takes place if this query yields the same result at that moment as it did in Step 1. (A conditional append is not necessary for all commands. Not all are sensitive to changes in the Event Store that might have occurred since the context was obtained.)

## More complicated slices

Sometimes processing a request is too much for a single slice.
Then the processor's function chains together several slices into a data flow.

Example:

- At first a query slice is called.
- Then a command slice is called with the result of the query slice and maybe some more parameters.
- After that another query slice is called with output from the first and second slice.
- Finally another command is called.
- In the end the processor's function returns some data assembled from output from several slices.

The execution of steps in such a data flow can be conditional, but never in a loop.

(Slices used in such a manner are called dice. The implementation of an interaction thus is sliced and diced.)

## Events

Events always have the same basic structure:

- **Event Type:** The type describes what the state change is about, representing the event's data. The event type is always formulated in the past tense, e.g., "taskAdded" or "gameFinished".
- **Payload:** The payload contains the data to be recorded.
- **State Data:** The data describing how the state has changed is provided flexibly within the payload.
- **Event ID:** By convention, every event also has an ID (UUID) that uniquely identifies it. This ID is part of the payload and is named like the event type + "ID", e.g., "taskAddedID".

Examples of events:

```json
{
    "eventType": "taskAdded",
    "payload": {
        "description": "...",

        "taskAddedID": "123-....987"
    }
}

{
    "eventType": "gameFinished",
    "payload": {
        "winner": "...",

        "gameFinishedID": "a2c-....9f7"
    }
}
```

The basic structure is the same for all events—Event Type, Payload—however, within the payload, events can differ significantly.

### Scopes

To connect related events, they are grouped into Scopes. Every event potentially opens a scope to which subsequent events can be assigned.

Such scopes can be nested to any depth. Every event in a nested scope (child scope) is part of all enclosing scopes (parent scopes).

By convention, the scopes to which an event belongs are also noted in the payload. There, the Event IDs of the events that opened the parent scopes are listed.

Examples:

```json
{
    "eventType": "competitionStarted",
    "payload": {
        "title": "...",

        "competitionStartedID": "178-....2bc"
    }
}

{
    "eventType": "gameStarted",
    "payload": {
        "players": ["...", "..."],

        "gameStartedID": "a2c-....9f7",
        "scopes": {
            "competitionStartedID": "178-....2bc"
        }
    }
}

{
    "eventType": "gameFinished",
    "payload": {
        "winner": "...",

        "gameFinishedID": "bdc-....42a",
        "scopes": {
            "gameStartedID": "a2c-....9f7",
            "competitionStartedID": "178-....2bc"
        }
    }
}
```